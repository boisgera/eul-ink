{
    "docs": [
        {
            "location": "/", 
            "text": "Overview", 
            "title": "Overview"
        }, 
        {
            "location": "/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/examples/", 
            "text": "TODO:\n plain text (no image, no link, no div, not attribute, etc.). \nNow that attributes \n divs are captured from HTML, it can become VERY\nnoisy, a filter like that could alleviate the problem. Test it on\npandoc's web site for example? This is interesting, we will have\nto 'flatten' the divs. At least get rid of everything that smells\ntoo much HTML (link \nmay\n be ok?), like raw html \n divs.\nWait there is no raw html in this case right? Get rid of it anyway.\n\n\nExamples\n\n\n import pandoc\n\n from pandoc.types import *\n\n\n def T(function):\n...     def _f(markdown):\n...         doc = pandoc.read(markdown)\n...         _doc = function(doc)\n...         if _doc is not None:\n...             doc = _doc\n...         print(pandoc.write(doc))\n...     return _f\n\n\n\nUppercase\n\n\n def capitalize(doc):\n...     for elt in pandoc.iter(doc):\n...         if isinstance(elt, Str):\n...             elt[0] = elt[0].upper()\n\n\n\n T(capitalize)(\"I can't feel my legs\")\nI CAN'T FEEL MY LEGS\n\nBLANKLINE\n\n\n\n\nTODO:\n extra NEWLINE in the output, solve this.\nOR maybe this is to be expected? A doc DOES END with a newline?\nSee what pandoc does about this.\n\n\nDe-emphasize\n\n\nTODO:\n think of the pattern: if something matches a condition, \n          replace it with something (and stop the iteration in this\n          branch? Or iterate on the new object?). \n          Pandoc-filters has the ability to let the \n          \"atomic transformation\" control the rest of the iteration\n          by calling walk. See how this is done, study walk.\n\n\n def capitalize(doc):\n...     for elt in pandoc.iter(doc):\n...         if isinstance(elt, Str):\n...             elt[0] = elt[0].upper()\n\n\n\n T(capitalize)(\"I can't feel my legs\")\nI CAN'T FEEL MY LEGS\n\nBLANKLINE\n\n\n\n\nTODO:\n extra NEWLINE in the output, solve this.\nOR maybe this is to be expected? A doc DOES END with a newline?\nSee what pandoc does about this.\n\n\nComments\n\n\nRemove everything between \n!-- BEGIN COMMENT --\n and \n!-- END COMMENT --\n.\nThe comment lines must appear on lines by themselves, \nwith blank lines surrounding them.\n\n\nTODO:\n find HTML RawBlocks, check for start/end markers, \nremove the items within.\n\n\nTODO:\n these scheme \nmay\n fail with tuples right?\n          Improve the \"Block holder\" detection.\n\n\n def begin_comment(elt):\n...     return isinstance(elt, RawBlock) and \\\n...            elt[0] == Format(u\"html\") and \\\n...            \"\n!-- BEGIN COMMENT --\n\" in elt[1]\n...\n\n def end_comment(elt):\n...     return isinstance(elt, RawBlock) and \\\n...            elt[0] == Format(u\"html\") and \\\n...            \"\n!-- END COMMENT --\n\" in elt[1]\n\n\n\nAnd now\n\n\n def ignore_comments(doc):\n...     for elt in pandoc.iter(doc):\n...         if isinstance(elt, list) and len(elt) \n 0 and isinstance(elt[0], Block):            \n...             children = []\n...             in_comment = False\n...             for child in elt[:]:\n...                 if begin_comment(child):\n...                     in_comment = True\n...                 elif end_comment(child):\n...                     in_comment = False\n...                 else:\n...                     if not in_comment:\n...                         children.append(child)\n...             elt[:] = children\n\n\n\nLeads to\n\n\n markdown = \"\"\"\\\n... Regular text\n...\n... \n!-- BEGIN COMMENT --\n\n... A comment\n...\n... \n!-- END COMMENT --\n\n... Moar regular text\n... \"\"\"\n\n T(ignore_comments)(markdown)\nRegular text\n\nBLANKLINE\n\nMoar regular text\n\nBLANKLINE\n\n\n\n\nTheorems\n\n\nConvert divs with class=\"theorem\" to LaTeX theorem environments in LaTeX output,\nand to numbered theorems in HTML output.\n\n\nTODO:\n to HTML version. Also export to LaTeX and HTML to see the outputs?\nCan it be done with an option to the \nT\n function?\n\n\nTODO:\n think of some support for visitor patterns? \nWe see a lot of \"do this in-place if this condition is met\". \nOr can we use the basic pandoc map/filter? Dunno. Think of it.\nArf with filter or map we have to deal with linearized data types?\nWe can linearize but can we reassemble. How are filter and map used\nfor hierarchial structures in functional programming? Have a look at\nHaskell (e.g. \nhttps://stackoverflow.com/questions/7624774/haskell-map-for-trees\n).\nSo, define a \npandoc.map\n helper?\n\n\n def is_theorem(elt):\n...     if isinstance(elt, Div):\n...         attrs = elt[0]\n...         _, classes, _ = attrs\n...         if \"theorem\" in classes:\n...             return True\n...     return False\n\n\n def LaTeX(text):\n...     return RawBlock(Format('latex'), text)\n\n\n def theorem_latex(doc):\n...     for elt in pandoc.iter(doc):\n...         if is_theorem(elt):\n...             id_ = elt[0][0]\n...             label = \"\"\n...             if id_:\n...                 label = r'\\label{' + id_ + '}'\n...             start_theorem = LaTeX(r'\\begin{theorem}' + label)\n...             end_theorem   = LaTeX(r'\\end{theorem}')\n...             elt[1][:] = [start_theorem] + elt[1] + [end_theorem]\n\n\n markdown = r\"\"\"\n... I'd like to introduce the following theorem:\n... \ndiv id='cauchy-formula' class='theorem'\n\n... $$f(z) = \\frac{1}{i2\\pi} \\int \\frac{f(w){w-z}\\, dw$$\n... \n/div\n\n... Right?\n... \"\"\"\n\n\n T(theorem_latex)(markdown)\nI'd like to introduce the following theorem:\n\nBLANKLINE\n\n::: {#cauchy-formula .theorem}\n\\begin{theorem}\\label{cauchy-formula}\n$$f(z) = \\frac{1}{i2\\pi} \\int \\frac{f(w){w-z}\\, dw$$\n\nBLANKLINE\n\n\\end{theorem}\n:::\n\nBLANKLINE\n\nRight?\n\nBLANKLINE\n\n\n\n\nNotebooks\n\n\nhttp://nbformat.readthedocs.io/en/latest/format_description.html#the-notebook-file-format\n\n\n#!/usr/bin/env python\n\n# Python Standard Library\nimport copy\nimport json\nimport os.path\nimport sys\n\n# Pandoc\nimport pandoc\n\n\ndef Notebook():\n    return copy.deepcopy(\n      {\n        \"cells\": [],\n        \"metadata\": {\n          \"kernelspec\": {\n            \"display_name\": \"Python 3\",\n            \"language\": \"python\",\n            \"name\": \"python3\"\n          },\n          \"language_info\": {\n            \"codemirror_mode\": {\n              \"name\": \"ipython\",\n              \"version\": 3\n            },\n            \"file_extension\": \".py\",\n            \"mimetype\": \"text/x-python\",\n            \"name\": \"python\",\n            \"nbconvert_exporter\": \"python\",\n            \"pygments_lexer\": \"ipython3\",\n            \"version\": \"3.6.4\"\n           }\n        },\n        \"nbformat\": 4,\n        \"nbformat_minor\": 2\n      }\n    )\n\ndef CodeCell():\n    return copy.deepcopy(\n      {\n        \"cell_type\": \"code\",\n        \"execution_count\": 1,\n        \"metadata\": {},\n        \"outputs\": [],\n        \"source\": []\n      }\n    )\n\ndef MarkdownCell(): \n    return copy.deepcopy(\n      {\n        \"cell_type\": \"markdown\",\n        \"metadata\": {},\n        \"source\": []\n      }\n    )\n\ndef notebookify(doc):\n    from pandoc.types import Pandoc, Meta, CodeBlock\n    notebook = Notebook()\n    cells = notebook['cells']\n    blocks = doc[1]\n    #print(blocks)\n    execution_count = 1\n    for block in blocks:\n        if isinstance(block, CodeBlock):\n            source = block[1]\n            code_cell = CodeCell()\n            code_cell['source'] = source\n            code_cell['execution_count'] = execution_count\n            execution_count += 1\n            cells.append(code_cell)\n        else:\n            wrapper = Pandoc(Meta({}), [block])\n            #print(wrapper)\n            source = pandoc.write(wrapper)\n            markdown_cell = MarkdownCell()\n            markdown_cell['source'] = source\n            cells.append(markdown_cell)\n    return notebook\n\nif __name__ == '__main__':\n    filename = sys.argv[1]\n    doc = pandoc.read(file=filename)\n    notebook = notebookify(doc)\n    base, _ = os.path.splitext(filename)\n    output = open(base + '.ipynb', 'w')\n    output.write(json.dumps(notebook, indent=2))\n    output.close()\n\n\n\nSave Web Documents\n\n\nWhen you find an interesting piece of content,\nyou may want to archive it on your computer.\nSince you are only interested in the content \nand not the full web page, \nthere are things in the HTML document \nthat you want probably want to remove in the process\n(navigation, social media, etc). \nAnd while you're at it, \nwhy not store the result as Markdown, \nwhich is a simpler document description language?\nWe know that thanks to pandoc, we can convert it \nto something fancy like PDF if the need arises.\n\n\nFor example, consider the \n\"Getting started\"\n \nsection of the the pandoc documentation. \nDownloading this document and converting it to Markdown is easy:\n\n\n$ curl https://pandoc.org/getting-started.html \n getting-started.html\n$ pandoc -o getting-started.md getting-started.html\n\n\n\nHowever, when you look at the result, this is very \"noisy\".\nIts starts with\n\n\n::: {#doc .container-fluid}\n::: {#flattr}\n[](https://pandoc.org){.FlattrButton}\n\n[![Flattr\nthis](https://api.flattr.com/button/flattr-badge-large.png \"Flattr this\")](https://flattr.com/thing/936364/Pandoc)\n:::\n\n::: {#paypal}\n![](https://www.paypalobjects.com/en_US/i/scr/pixel.gif){width=\"1\"\nheight=\"1\"}\n:::\n\n[Pandoc]{.big} \u00a0 [a universal document converter]{.small}\n\n::: {#bd}\n::: {.navbar-header}\n[Toggle navigation]{.sr-only} []{.icon-bar} []{.icon-bar} []{.icon-bar}\n:::\n\n::: {.navbar-collapse .collapse}\n-   [About](index.html)\n-   [Installing](installing.html)\n-   ...\n:::\n\n::: {.col-md-9 .col-sm-8 role=\"main\"}\n::: {.row}\n::: {#toc}\n-   [Step 1: Install pandoc](#step-1-install-pandoc)\n-   [Step 2: Open a terminal](#step-2-open-a-terminal)\n-   ...\n:::\n\n\n\nThere are two different kind of things here:\n\n\n\n\n\n\na \"div soup\", characterized by the sheer number of \n:::\n symbols\n1\n.\n    In pandoc-flavored Markdown, the \n:::\n syntax corresponds to\n    the \ndiv\n tag in HTML.\n    Div hierarchies are often used to style HTML elements, \n    so this is something that we don't need anymore.\n\n\n\n\n\n\ncomponents that don't make sense out of the web page: \n    some buttons, a navigation bar, etc.\n\n\n\n\n\n\nIt's only after this long and noisy preamble that you find the real content.\nIt looks like this:\n\n\nThis document is for people who are unfamiliar with command line tools.\nCommand-line experts can go straight to the [User's Guide](README.html)\nor the pandoc man page.\n\nStep 1: Install pandoc\n======================\n\nFirst, install pandoc, following the [instructions for your\nplatform](installing.html).\n\nStep 2: Open a terminal\n=======================\n\n...\n\n\n\nAnd finally, you close the four divs in which the content is nested:\n\n\n:::\n:::\n:::\n:::\n\n\n\nThis is probably not the document that you want to store. \nTo simplify it, we are going to remove all the hierarchy \nof divs and get rid of the preamble.\n\n\nUnpack Divs\n\n\ndef unpack_divs(doc):\n    \"Unpack Divs - Two-pass, In-Place Algorithm\"\n\n    # Locate the divs and extract the relevant data\n    matches = []\n    for elt, path in pandoc.iter(doc, path=True):\n        if isinstance(elt, Div):\n            div = elt\n            parent, index = path[-1]\n            contents = div[1]\n            # Blocks are always held in lists (cf. the document model).\n            assert isinstance(parent, list)\n            matches.append((parent, index, contents))\n\n    # We need to unpack the divs in reverse document order \n    # not to invalidate the remaining matches.\n    for parent, index, contents in reversed(matches):\n        del parent[index]\n        parent[index:index] = contents\n\n    return doc\n\n\n\nUnpack Divs (Variant)\n\n\nYou may find that the approach above is convoluted. \nIt's actually perfectly possible to achieve the same transformation \nin one pass if we build a new document \ninstead of modifying the original.\n\n\nThis is best achieved using recursion. To get a feeling how recursion\ncan be used to create modified copies of a document, we can first \nimplement a copy without modification:\n\n\ndef copy(elt):\n    \"Copy the document (or document fragment) recursively\"\n    # List, tuple, map and (non-primitive) Pandoc types\n    if hasattr(elt, \"__iter__\") and not isinstance(elt, String):\n        type_ = type(elt)\n        if type_ is map:\n            args = list(elt.items())\n        else:\n            args = elt[:]\n        new_args = [copy(arg) for arg in args]\n        if issubclass(type_, (list, tuple, map)):\n            return type_(new_args)\n        else: # Pandoc types\n            return type_(*new_args)\n    else: # Python atomic (immutable) types\n        return elt\n\n\n\nNote that the name of the function argument is not \ndoc\n but \nelt\n since the \n\ncopy\n function may be used with any document fragment, not merely with a\ndocument.\n\n\nLet's go back to our original problem, which is div unpacking. \nSince divs are held in lists of blocks, \nwe define a predicate that identifies lists of blocks:\n\n\ndef is_blocks(elt): \n    \"Identify (non-empty) lists of blocks\"\n    return isinstance(elt, list) and \\\n           len(elt)!=0 and \\\n           isinstance(elt[0], Block)\n\n\n\nAnd now we are ready to define the alternate implementation of \nunpack_div\n.\nFirst, we detect when \nelt\n is a list of blocks and \nin this case, if some of these blocks are divs, \nwe expand them:\n\n\ndef unpack_divs(elt):\n    \"Unpack Divs - One-Pass, Recursive, Non-Destructive Algorithm\"\n\n    # Find the list of blocks and their div children and unpack them\n    if is_blocks(elt):\n        blocks = elt\n        new_blocks = []\n        for block in blocks:\n            if isinstance(block, Div):\n                div = block\n                contents = div[1]\n                new_blocks.extend(unpack_divs(contents))\n            else:\n                new_blocks.append(unpack_divs(block))\n        assert not any([isinstance(block, Div) for block in new_blocks])\n        return new_blocks\n\n\n\nWe also need to handle the remaining cases, but this is easy\nsince this is similar to what the recursive \ncopy\n is doing:\n\n\n    # List, tuple, map and (non-primitive) Pandoc types\n    elif hasattr(elt, \"__iter__\") and not isinstance(elt, String):\n        type_ = type(elt)\n        if type_ is map:\n            args = list(elt.items())\n        else:\n            args = elt[:]\n        new_args = [unpack_divs(arg) for arg in args]\n        if issubclass(type_, (list, tuple, map)):\n            return type_(new_args)\n        else: # Pandoc types\n            return type_(*new_args)\n    else: # Python atomic (immutable) types\n        return elt\n\n\n\nRemove The Preamble\n\n\nAt this stage, if you wrap any of the \nunpack_divs\n into\n\n\n# file: simplify.py\nif __name__ == \"__main__\":\n    url = 'https://pandoc.org/getting-started.html'\n    src = urllib.request.urlopen(url).read()\n    doc = pandoc.read(src, format=\"html\")\n    doc = unpack_divs(doc)\n    print(pandoc.write(doc, format=\"markdown\", options=[\"-s\"]))\n\n\n\nThis is what you get when you execute the script:\n\n\n$ python simplify.py \n---\nlang: en\ntitle: 'Pandoc - Getting started with pandoc'\nviewport: 'width=device-width, initial-scale=1.0'\n---\n\n[](https://pandoc.org){.FlattrButton}\n\n[![Flattr\nthis](https://api.flattr.com/button/flattr-badge-large.png \"Flattr this\")](https://flattr.com/thing/936364/Pandoc)\n\n![](https://www.paypalobjects.com/en_US/i/scr/pixel.gif){width=\"1\"\nheight=\"1\"}\n\n[Pandoc]{.big} \u00a0 [a universal document converter]{.small}\n\n[Toggle navigation]{.sr-only} []{.icon-bar} []{.icon-bar} []{.icon-bar}\n\n-   [About](index.html)\n-   [Installing](installing.html)\n-   ...\n\n-   [Step 1: Install pandoc](#step-1-install-pandoc)\n-   [Step 2: Open a terminal](#step-2-open-a-terminal)\n-   ...\n\nThis document is for people who are unfamiliar with command line tools.\nCommand-line experts can go straight to the [User's Guide](README.html)\nor the pandoc man page.\n\nStep 1: Install pandoc\n======================\n\nFirst, install pandoc, following the [instructions for your\nplatform](installing.html).\n\nStep 2: Open a terminal\n=======================\n\n...\n\nIf you get stuck, you can always ask questions on the\n[pandoc-discuss](http://groups.google.com/group/pandoc-discuss) mailing\nlist. But be sure to check the [FAQs](faqs.html) first, and search\nthrough the mailing list to see if your question has been answered\nbefore.\n\n\n\nThis is better, since there is no more div, but we still need to get rid \nof everything before the first real paragraph, \nthe one that starts with some plain text: \"This document ...\".\nSo we can detect this first paragraph \n\u2013 for example because it starts with an instance of \nStr\n \u2013 \nand remove everything before it from the document:\n\n\ndef remove_preamble(doc):\n    \"Remove everything before the first real paragraph\"\n    blocks = doc[1]\n    for i, block in enumerate(blocks):\n        if isinstance(block, Para):\n            para = block\n            inlines = para[0]\n            if len(inlines) \n 0 and isinstance(inlines[0], Str):\n                break\n    doc[1] = blocks[i:]\n    return doc\n\n\n\nNow, change the main entry point accordingly:\n\n\n# file: simplify.py\nif __name__ == \"__main__\":\n    url = 'https://pandoc.org/getting-started.html'\n    src = urllib.request.urlopen(url).read()\n    doc = pandoc.read(src, format=\"html\")\n    doc = unpack_divs(doc)\n    doc = remove_preamble(doc)\n    print(pandoc.write(doc, format=\"markdown\", options=[\"-s\"]))\n\n\n\nand this is what you get:\n\n\n$ python simplify.py\n---\nlang: en\ntitle: 'Pandoc - Getting started with pandoc'\nviewport: 'width=device-width, initial-scale=1.0'\n---\n\nThis document is for people who are unfamiliar with command line tools.\nCommand-line experts can go straight to the [User's Guide](README.html)\nor the pandoc man page.\n\nStep 1: Install pandoc\n======================\n\nFirst, install pandoc, following the [instructions for your\nplatform](installing.html).\n\nStep 2: Open a terminal\n=======================\n\n...\n\nIf you get stuck, you can always ask questions on the\n[pandoc-discuss](http://groups.google.com/group/pandoc-discuss) mailing\nlist. But be sure to check the [FAQs](faqs.html) first, and search\nthrough the mailing list to see if your question has been answered\nbefore.\n\n\n\nMission accomplished!\n\n\n\n\n\n\n\n\n\n\nWe could also disable the \nnative_divs\n option in pandoc to get rid \nof the div soup, but where would be the fun then?", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "import pandoc  from pandoc.types import *  def T(function):\n...     def _f(markdown):\n...         doc = pandoc.read(markdown)\n...         _doc = function(doc)\n...         if _doc is not None:\n...             doc = _doc\n...         print(pandoc.write(doc))\n...     return _f", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#uppercase", 
            "text": "def capitalize(doc):\n...     for elt in pandoc.iter(doc):\n...         if isinstance(elt, Str):\n...             elt[0] = elt[0].upper()  T(capitalize)(\"I can't feel my legs\")\nI CAN'T FEEL MY LEGS BLANKLINE   TODO:  extra NEWLINE in the output, solve this.\nOR maybe this is to be expected? A doc DOES END with a newline?\nSee what pandoc does about this.", 
            "title": "Uppercase"
        }, 
        {
            "location": "/examples/#de-emphasize", 
            "text": "TODO:  think of the pattern: if something matches a condition, \n          replace it with something (and stop the iteration in this\n          branch? Or iterate on the new object?). \n          Pandoc-filters has the ability to let the \n          \"atomic transformation\" control the rest of the iteration\n          by calling walk. See how this is done, study walk.   def capitalize(doc):\n...     for elt in pandoc.iter(doc):\n...         if isinstance(elt, Str):\n...             elt[0] = elt[0].upper()  T(capitalize)(\"I can't feel my legs\")\nI CAN'T FEEL MY LEGS BLANKLINE   TODO:  extra NEWLINE in the output, solve this.\nOR maybe this is to be expected? A doc DOES END with a newline?\nSee what pandoc does about this.", 
            "title": "De-emphasize"
        }, 
        {
            "location": "/examples/#comments", 
            "text": "Remove everything between  !-- BEGIN COMMENT --  and  !-- END COMMENT -- .\nThe comment lines must appear on lines by themselves, \nwith blank lines surrounding them.  TODO:  find HTML RawBlocks, check for start/end markers, \nremove the items within.  TODO:  these scheme  may  fail with tuples right?\n          Improve the \"Block holder\" detection.   def begin_comment(elt):\n...     return isinstance(elt, RawBlock) and \\\n...            elt[0] == Format(u\"html\") and \\\n...            \" !-- BEGIN COMMENT -- \" in elt[1]\n...  def end_comment(elt):\n...     return isinstance(elt, RawBlock) and \\\n...            elt[0] == Format(u\"html\") and \\\n...            \" !-- END COMMENT -- \" in elt[1]  And now   def ignore_comments(doc):\n...     for elt in pandoc.iter(doc):\n...         if isinstance(elt, list) and len(elt)   0 and isinstance(elt[0], Block):            \n...             children = []\n...             in_comment = False\n...             for child in elt[:]:\n...                 if begin_comment(child):\n...                     in_comment = True\n...                 elif end_comment(child):\n...                     in_comment = False\n...                 else:\n...                     if not in_comment:\n...                         children.append(child)\n...             elt[:] = children  Leads to   markdown = \"\"\"\\\n... Regular text\n...\n...  !-- BEGIN COMMENT -- \n... A comment\n...\n...  !-- END COMMENT -- \n... Moar regular text\n... \"\"\"  T(ignore_comments)(markdown)\nRegular text BLANKLINE \nMoar regular text BLANKLINE", 
            "title": "Comments"
        }, 
        {
            "location": "/examples/#theorems", 
            "text": "Convert divs with class=\"theorem\" to LaTeX theorem environments in LaTeX output,\nand to numbered theorems in HTML output.  TODO:  to HTML version. Also export to LaTeX and HTML to see the outputs?\nCan it be done with an option to the  T  function?  TODO:  think of some support for visitor patterns? \nWe see a lot of \"do this in-place if this condition is met\". \nOr can we use the basic pandoc map/filter? Dunno. Think of it.\nArf with filter or map we have to deal with linearized data types?\nWe can linearize but can we reassemble. How are filter and map used\nfor hierarchial structures in functional programming? Have a look at\nHaskell (e.g.  https://stackoverflow.com/questions/7624774/haskell-map-for-trees ).\nSo, define a  pandoc.map  helper?   def is_theorem(elt):\n...     if isinstance(elt, Div):\n...         attrs = elt[0]\n...         _, classes, _ = attrs\n...         if \"theorem\" in classes:\n...             return True\n...     return False  def LaTeX(text):\n...     return RawBlock(Format('latex'), text)  def theorem_latex(doc):\n...     for elt in pandoc.iter(doc):\n...         if is_theorem(elt):\n...             id_ = elt[0][0]\n...             label = \"\"\n...             if id_:\n...                 label = r'\\label{' + id_ + '}'\n...             start_theorem = LaTeX(r'\\begin{theorem}' + label)\n...             end_theorem   = LaTeX(r'\\end{theorem}')\n...             elt[1][:] = [start_theorem] + elt[1] + [end_theorem]  markdown = r\"\"\"\n... I'd like to introduce the following theorem:\n...  div id='cauchy-formula' class='theorem' \n... $$f(z) = \\frac{1}{i2\\pi} \\int \\frac{f(w){w-z}\\, dw$$\n...  /div \n... Right?\n... \"\"\"  T(theorem_latex)(markdown)\nI'd like to introduce the following theorem: BLANKLINE \n::: {#cauchy-formula .theorem}\n\\begin{theorem}\\label{cauchy-formula}\n$$f(z) = \\frac{1}{i2\\pi} \\int \\frac{f(w){w-z}\\, dw$$ BLANKLINE \n\\end{theorem}\n::: BLANKLINE \nRight? BLANKLINE", 
            "title": "Theorems"
        }, 
        {
            "location": "/examples/#notebooks", 
            "text": "http://nbformat.readthedocs.io/en/latest/format_description.html#the-notebook-file-format  #!/usr/bin/env python\n\n# Python Standard Library\nimport copy\nimport json\nimport os.path\nimport sys\n\n# Pandoc\nimport pandoc\n\n\ndef Notebook():\n    return copy.deepcopy(\n      {\n        \"cells\": [],\n        \"metadata\": {\n          \"kernelspec\": {\n            \"display_name\": \"Python 3\",\n            \"language\": \"python\",\n            \"name\": \"python3\"\n          },\n          \"language_info\": {\n            \"codemirror_mode\": {\n              \"name\": \"ipython\",\n              \"version\": 3\n            },\n            \"file_extension\": \".py\",\n            \"mimetype\": \"text/x-python\",\n            \"name\": \"python\",\n            \"nbconvert_exporter\": \"python\",\n            \"pygments_lexer\": \"ipython3\",\n            \"version\": \"3.6.4\"\n           }\n        },\n        \"nbformat\": 4,\n        \"nbformat_minor\": 2\n      }\n    )\n\ndef CodeCell():\n    return copy.deepcopy(\n      {\n        \"cell_type\": \"code\",\n        \"execution_count\": 1,\n        \"metadata\": {},\n        \"outputs\": [],\n        \"source\": []\n      }\n    )\n\ndef MarkdownCell(): \n    return copy.deepcopy(\n      {\n        \"cell_type\": \"markdown\",\n        \"metadata\": {},\n        \"source\": []\n      }\n    )\n\ndef notebookify(doc):\n    from pandoc.types import Pandoc, Meta, CodeBlock\n    notebook = Notebook()\n    cells = notebook['cells']\n    blocks = doc[1]\n    #print(blocks)\n    execution_count = 1\n    for block in blocks:\n        if isinstance(block, CodeBlock):\n            source = block[1]\n            code_cell = CodeCell()\n            code_cell['source'] = source\n            code_cell['execution_count'] = execution_count\n            execution_count += 1\n            cells.append(code_cell)\n        else:\n            wrapper = Pandoc(Meta({}), [block])\n            #print(wrapper)\n            source = pandoc.write(wrapper)\n            markdown_cell = MarkdownCell()\n            markdown_cell['source'] = source\n            cells.append(markdown_cell)\n    return notebook\n\nif __name__ == '__main__':\n    filename = sys.argv[1]\n    doc = pandoc.read(file=filename)\n    notebook = notebookify(doc)\n    base, _ = os.path.splitext(filename)\n    output = open(base + '.ipynb', 'w')\n    output.write(json.dumps(notebook, indent=2))\n    output.close()", 
            "title": "Notebooks"
        }, 
        {
            "location": "/examples/#save-web-documents", 
            "text": "When you find an interesting piece of content,\nyou may want to archive it on your computer.\nSince you are only interested in the content \nand not the full web page, \nthere are things in the HTML document \nthat you want probably want to remove in the process\n(navigation, social media, etc). \nAnd while you're at it, \nwhy not store the result as Markdown, \nwhich is a simpler document description language?\nWe know that thanks to pandoc, we can convert it \nto something fancy like PDF if the need arises.  For example, consider the  \"Getting started\"  \nsection of the the pandoc documentation. \nDownloading this document and converting it to Markdown is easy:  $ curl https://pandoc.org/getting-started.html   getting-started.html\n$ pandoc -o getting-started.md getting-started.html  However, when you look at the result, this is very \"noisy\".\nIts starts with  ::: {#doc .container-fluid}\n::: {#flattr}\n[](https://pandoc.org){.FlattrButton}\n\n[![Flattr\nthis](https://api.flattr.com/button/flattr-badge-large.png \"Flattr this\")](https://flattr.com/thing/936364/Pandoc)\n:::\n\n::: {#paypal}\n![](https://www.paypalobjects.com/en_US/i/scr/pixel.gif){width=\"1\"\nheight=\"1\"}\n:::\n\n[Pandoc]{.big} \u00a0 [a universal document converter]{.small}\n\n::: {#bd}\n::: {.navbar-header}\n[Toggle navigation]{.sr-only} []{.icon-bar} []{.icon-bar} []{.icon-bar}\n:::\n\n::: {.navbar-collapse .collapse}\n-   [About](index.html)\n-   [Installing](installing.html)\n-   ...\n:::\n\n::: {.col-md-9 .col-sm-8 role=\"main\"}\n::: {.row}\n::: {#toc}\n-   [Step 1: Install pandoc](#step-1-install-pandoc)\n-   [Step 2: Open a terminal](#step-2-open-a-terminal)\n-   ...\n:::  There are two different kind of things here:    a \"div soup\", characterized by the sheer number of  :::  symbols 1 .\n    In pandoc-flavored Markdown, the  :::  syntax corresponds to\n    the  div  tag in HTML.\n    Div hierarchies are often used to style HTML elements, \n    so this is something that we don't need anymore.    components that don't make sense out of the web page: \n    some buttons, a navigation bar, etc.    It's only after this long and noisy preamble that you find the real content.\nIt looks like this:  This document is for people who are unfamiliar with command line tools.\nCommand-line experts can go straight to the [User's Guide](README.html)\nor the pandoc man page.\n\nStep 1: Install pandoc\n======================\n\nFirst, install pandoc, following the [instructions for your\nplatform](installing.html).\n\nStep 2: Open a terminal\n=======================\n\n...  And finally, you close the four divs in which the content is nested:  :::\n:::\n:::\n:::  This is probably not the document that you want to store. \nTo simplify it, we are going to remove all the hierarchy \nof divs and get rid of the preamble.", 
            "title": "Save Web Documents"
        }, 
        {
            "location": "/examples/#unpack-divs", 
            "text": "def unpack_divs(doc):\n    \"Unpack Divs - Two-pass, In-Place Algorithm\"\n\n    # Locate the divs and extract the relevant data\n    matches = []\n    for elt, path in pandoc.iter(doc, path=True):\n        if isinstance(elt, Div):\n            div = elt\n            parent, index = path[-1]\n            contents = div[1]\n            # Blocks are always held in lists (cf. the document model).\n            assert isinstance(parent, list)\n            matches.append((parent, index, contents))\n\n    # We need to unpack the divs in reverse document order \n    # not to invalidate the remaining matches.\n    for parent, index, contents in reversed(matches):\n        del parent[index]\n        parent[index:index] = contents\n\n    return doc", 
            "title": "Unpack Divs"
        }, 
        {
            "location": "/examples/#unpack-divs-variant", 
            "text": "You may find that the approach above is convoluted. \nIt's actually perfectly possible to achieve the same transformation \nin one pass if we build a new document \ninstead of modifying the original.  This is best achieved using recursion. To get a feeling how recursion\ncan be used to create modified copies of a document, we can first \nimplement a copy without modification:  def copy(elt):\n    \"Copy the document (or document fragment) recursively\"\n    # List, tuple, map and (non-primitive) Pandoc types\n    if hasattr(elt, \"__iter__\") and not isinstance(elt, String):\n        type_ = type(elt)\n        if type_ is map:\n            args = list(elt.items())\n        else:\n            args = elt[:]\n        new_args = [copy(arg) for arg in args]\n        if issubclass(type_, (list, tuple, map)):\n            return type_(new_args)\n        else: # Pandoc types\n            return type_(*new_args)\n    else: # Python atomic (immutable) types\n        return elt  Note that the name of the function argument is not  doc  but  elt  since the  copy  function may be used with any document fragment, not merely with a\ndocument.  Let's go back to our original problem, which is div unpacking. \nSince divs are held in lists of blocks, \nwe define a predicate that identifies lists of blocks:  def is_blocks(elt): \n    \"Identify (non-empty) lists of blocks\"\n    return isinstance(elt, list) and \\\n           len(elt)!=0 and \\\n           isinstance(elt[0], Block)  And now we are ready to define the alternate implementation of  unpack_div .\nFirst, we detect when  elt  is a list of blocks and \nin this case, if some of these blocks are divs, \nwe expand them:  def unpack_divs(elt):\n    \"Unpack Divs - One-Pass, Recursive, Non-Destructive Algorithm\"\n\n    # Find the list of blocks and their div children and unpack them\n    if is_blocks(elt):\n        blocks = elt\n        new_blocks = []\n        for block in blocks:\n            if isinstance(block, Div):\n                div = block\n                contents = div[1]\n                new_blocks.extend(unpack_divs(contents))\n            else:\n                new_blocks.append(unpack_divs(block))\n        assert not any([isinstance(block, Div) for block in new_blocks])\n        return new_blocks  We also need to handle the remaining cases, but this is easy\nsince this is similar to what the recursive  copy  is doing:      # List, tuple, map and (non-primitive) Pandoc types\n    elif hasattr(elt, \"__iter__\") and not isinstance(elt, String):\n        type_ = type(elt)\n        if type_ is map:\n            args = list(elt.items())\n        else:\n            args = elt[:]\n        new_args = [unpack_divs(arg) for arg in args]\n        if issubclass(type_, (list, tuple, map)):\n            return type_(new_args)\n        else: # Pandoc types\n            return type_(*new_args)\n    else: # Python atomic (immutable) types\n        return elt", 
            "title": "Unpack Divs (Variant)"
        }, 
        {
            "location": "/examples/#remove-the-preamble", 
            "text": "At this stage, if you wrap any of the  unpack_divs  into  # file: simplify.py\nif __name__ == \"__main__\":\n    url = 'https://pandoc.org/getting-started.html'\n    src = urllib.request.urlopen(url).read()\n    doc = pandoc.read(src, format=\"html\")\n    doc = unpack_divs(doc)\n    print(pandoc.write(doc, format=\"markdown\", options=[\"-s\"]))  This is what you get when you execute the script:  $ python simplify.py \n---\nlang: en\ntitle: 'Pandoc - Getting started with pandoc'\nviewport: 'width=device-width, initial-scale=1.0'\n---\n\n[](https://pandoc.org){.FlattrButton}\n\n[![Flattr\nthis](https://api.flattr.com/button/flattr-badge-large.png \"Flattr this\")](https://flattr.com/thing/936364/Pandoc)\n\n![](https://www.paypalobjects.com/en_US/i/scr/pixel.gif){width=\"1\"\nheight=\"1\"}\n\n[Pandoc]{.big} \u00a0 [a universal document converter]{.small}\n\n[Toggle navigation]{.sr-only} []{.icon-bar} []{.icon-bar} []{.icon-bar}\n\n-   [About](index.html)\n-   [Installing](installing.html)\n-   ...\n\n-   [Step 1: Install pandoc](#step-1-install-pandoc)\n-   [Step 2: Open a terminal](#step-2-open-a-terminal)\n-   ...\n\nThis document is for people who are unfamiliar with command line tools.\nCommand-line experts can go straight to the [User's Guide](README.html)\nor the pandoc man page.\n\nStep 1: Install pandoc\n======================\n\nFirst, install pandoc, following the [instructions for your\nplatform](installing.html).\n\nStep 2: Open a terminal\n=======================\n\n...\n\nIf you get stuck, you can always ask questions on the\n[pandoc-discuss](http://groups.google.com/group/pandoc-discuss) mailing\nlist. But be sure to check the [FAQs](faqs.html) first, and search\nthrough the mailing list to see if your question has been answered\nbefore.  This is better, since there is no more div, but we still need to get rid \nof everything before the first real paragraph, \nthe one that starts with some plain text: \"This document ...\".\nSo we can detect this first paragraph \n\u2013 for example because it starts with an instance of  Str  \u2013 \nand remove everything before it from the document:  def remove_preamble(doc):\n    \"Remove everything before the first real paragraph\"\n    blocks = doc[1]\n    for i, block in enumerate(blocks):\n        if isinstance(block, Para):\n            para = block\n            inlines = para[0]\n            if len(inlines)   0 and isinstance(inlines[0], Str):\n                break\n    doc[1] = blocks[i:]\n    return doc  Now, change the main entry point accordingly:  # file: simplify.py\nif __name__ == \"__main__\":\n    url = 'https://pandoc.org/getting-started.html'\n    src = urllib.request.urlopen(url).read()\n    doc = pandoc.read(src, format=\"html\")\n    doc = unpack_divs(doc)\n    doc = remove_preamble(doc)\n    print(pandoc.write(doc, format=\"markdown\", options=[\"-s\"]))  and this is what you get:  $ python simplify.py\n---\nlang: en\ntitle: 'Pandoc - Getting started with pandoc'\nviewport: 'width=device-width, initial-scale=1.0'\n---\n\nThis document is for people who are unfamiliar with command line tools.\nCommand-line experts can go straight to the [User's Guide](README.html)\nor the pandoc man page.\n\nStep 1: Install pandoc\n======================\n\nFirst, install pandoc, following the [instructions for your\nplatform](installing.html).\n\nStep 2: Open a terminal\n=======================\n\n...\n\nIf you get stuck, you can always ask questions on the\n[pandoc-discuss](http://groups.google.com/group/pandoc-discuss) mailing\nlist. But be sure to check the [FAQs](faqs.html) first, and search\nthrough the mailing list to see if your question has been answered\nbefore.  Mission accomplished!      We could also disable the  native_divs  option in pandoc to get rid \nof the div soup, but where would be the fun then?", 
            "title": "Remove The Preamble"
        }, 
        {
            "location": "/ast/", 
            "text": "AST / Document (Meta-)Model\n\n\nUse the new metaclass-based representation to drive an exploration of the\ndocument model. Link to the proper documentation when needed, or use\nexemple from markdown text to see what every construct is about.\n\n\nExplore an existing document or create from scratch?\nFirst explore, then build from scratch?\n\n\nExplain that the person willing to analyze/transform documents has to \nunderstand how each (or some of the) document pieces are represented?\nAnd that it's what we try to do here?\n\n\n\n\n import pandoc\n\n from pandoc.types import *\n\n\n\n text = \"Hello, World!\"\n\n doc = pandoc.read(text)\n\n doc\nPandoc(Meta(map()), [Para([Str('Hello,'), Space(), Str('World!')])])\n\n\n\nA document is an instance of the \nPandoc\n class; it has two arguments\n\n\n Pandoc\nPandoc(Meta, [Block])\n\n\n\nThe first argument, the instance of \nMeta\n, represents the document metadata.\nSince in this very simple example there is no metadata, we will ignore it and\nfocus on the second argument instead, the document contents, which \nis a list of blocks:\n\n\n blocks = doc[1]\n\n blocks\n[Para([Str('Hello,'), Space(), Str('World!')])]\n\n\n\nActually, there is a single block here\n\n\n len(blocks)\n1\n\n\n\nThere are several possible types of blocks: headers, paragraphs, lists, etc.\n\n\n Block\nBlock = Plain([Inline])\n      | Para([Inline])\n      | LineBlock([[Inline]])\n      | CodeBlock(Attr, String)\n      | RawBlock(Format, String)\n      | BlockQuote([Block])\n      | OrderedList(ListAttributes, [[Block]])\n      | BulletList([[Block]])\n      | DefinitionList([([Inline], [[Block]])])\n      | Header(Int, Attr, [Inline])\n      | HorizontalRule()\n      | Table([Inline], [Alignment], [Double], [TableCell], [[TableCell]])\n      | Div(Attr, [Block])\n      | Null()\n\n\n\nHere our single block is a paragraph:\n\n\n para = blocks[0]\n\n para\nPara([Str('Hello,'), Space(), Str('World!')])\n\n isinstance(para, Para)\nTrue\n\n\n\nIn general, paragraphs contain lists of inline elements:\n\n\n Para\nPara([Inline])\n\n inlines = para[0]\n\n\n\nInlines can be several things: ordinary text, emphasized text,\nstrong text, etc.\n\n\n Inline\nInline = Str(String)\n       | Emph([Inline])\n       | Strong([Inline])\n       | Strikeout([Inline])\n       | Superscript([Inline])\n       | Subscript([Inline])\n       | SmallCaps([Inline])\n       | Quoted(QuoteType, [Inline])\n       | Cite([Citation], [Inline])\n       | Code(Attr, String)\n       | Space()\n       | SoftBreak()\n       | LineBreak()\n       | Math(MathType, String)\n       | RawInline(Format, String)\n       | Link(Attr, [Inline], Target)\n       | Image(Attr, [Inline], Target)\n       | Note([Block])\n       | Span(Attr, [Inline])\n\n\n\nHere we simply have a mixture of ordinary text and space.\n\n\n inlines = para[0]\n\n inlines\n[Str('Hello,'), Space(), Str('World!')]\n\n\n\nInstances of \nSpace\n have no argument while instances of \nStr\n \ncontain a text string\n\n\n Space\nSpace()\n\n Str\nStr(String)\n\n String\n\nclass 'str'\n\n\n\n\nFinally\n\n\n print(inlines[0][0] + \" \" + inlines[2][0])\nHello, World!\n\n\n\nHelpers\n\n\nWe introduce the helper function \nshow\n to display a document or document \nfragment (inline or block) as markdown:\n\n\n def show(elt):\n...     if isinstance(elt, Pandoc):\n...         doc = elt\n...         print(pandoc.write(doc, format=\"markdown\"))\n...     elif isinstance(elt, list):\n...         elts = elt\n...         if len(elts) \n 0:\n...             if isinstance(elts[0], Block):\n...                 blocks = elts\n...                 show(Pandoc(Meta({}), blocks))\n...             elif isinstance(elts[0], Inline):\n...                 inlines = elts\n...                 block = Plain(elts)\n...                 show([block])\n...     elif isinstance(elt, (Inline, Block)):\n...         show([elt])\n\n\n\nWe also introduce a function \nfind\n to get the first element of a given type\nin a document or document fragment:\n\n\n def find(elt, type):\n...     for _elt in pandoc.iter(elt):\n...         if isinstance(_elt, type):\n...             return _elt\n\n\n\nWe monkey-patch the base class for pandoc types to be able to call \nfind\n \nas a method:\n\n\n pandoc.types.Type.find = find\n\n\n\nTables\n\n\nReference:\n \nPandoc User's Guide / Tables\n\n\nSimple tables in markdown typically look like this:\n\n\n text = \"\"\"\n...   Right     Left     Center     Default\n... -------     ------ ----------   -------\n...      12     12        12            12\n...     123     123       123          123\n...       1     1          1             1\n... ---------------------------------------\n...\n... Table: Demonstration of simple table syntax.\n... \"\"\"\n\n\n\nA table is defined by 5 arguments:\n\n\n Table\nTable([Inline], [Alignment], [Double], [TableCell], [[TableCell]])\n\n\n\nThey define respectively the table caption, column alignments, column widths,\nheaders and rows. The most important are the last two, headers and rows.\nHeaders are described by a list of table cells: it's the content of \nfirst table row. The last argument refers to the remaining table rows,\neach row being described as a list of table cells.\n\n\nThe content of a table cell can be arbitrarily complex: \nanything that can be used in a document content (except for the metadata) \ncan be used in a table cell.\nActually, \nTableCell\n is not a new type, but an alias for \"list of blocks\":\n\n\n TableCell\nTableCell = [Block]\n\n\n\nLet's have a look at the attributes of the table above:\n\n\n doc = pandoc.read(text)\n\n table = doc.find(Table)\n\n caption, alignments, widths, headers, rows = table[:]\n\n\n\nHere are the column headers:\n\n\n headers\n[[Plain([Str('Right')])], [Plain([Str('Left')])], [Plain([Str('Center')])], [Plain([Str('Default')])]]\n\n for cell in headers:\n...     show(cell)\nRight\n\nBLANKLINE\n\nLeft\n\nBLANKLINE\n\nCenter\n\nBLANKLINE\n\nDefault\n\nBLANKLINE\n\n\n\n\nThe structure of rows are similar. \nFor example, we can display the contents of the first row:\n\n\n rows\n[[[Plain([Str('12')])], [Plain([Str('12')])], [Plain([Str('12')])], [Plain([Str('12')])]], [[Plain([Str('123')])], [Plain([Str('123')])], [Plain([Str('123')])], [Plain([Str('123')])]], [[Plain([Str('1')])], [Plain([Str('1')])], [Plain([Str('1')])], [Plain([Str('1')])]]]\n\n first_row = rows[0]\n\n for cell in first_row:\n...     show(cell)\n12\n\nBLANKLINE\n\n12\n\nBLANKLINE\n\n12\n\nBLANKLINE\n\n12\n\nBLANKLINE\n\n\n\n\nThe three other table arguments are caption, column alignments and column widths.\nCaption is the obvious one: it's the content of the (optional) table caption,\ndescribed as a list of inlines:\n\n\n caption\n[Str('Demonstration'), Space(), Str('of'), Space(), Str('simple'), Space(), Str('table'), Space(), Str('syntax.')]\n\n\n\nColumn alignments is a list of alignment options, \namong the four possible choices below:\n\n\n Alignment\nAlignment = AlignLeft()\n          | AlignRight()\n          | AlignCenter()\n          | AlignDefault()\n\n\n\nIn the current table, the four kinds are effectively used:\n\n\n alignments\n[AlignRight(), AlignLeft(), AlignCenter(), AlignDefault()]\n\n\n\nThe third argument is a list of floating-point numbers which are \nfractions of 1 and determine the column widths. \nEither their sum is one of they are all set to zero, \nin which vase the attribute carries no information. \nHere, we are in this default case:\n\n\n widths\n[0.0, 0.0, 0.0, 0.0]\n\n\n\nColumn widths are relevant in the context of multiline tables\n(see \nPandoc User's Guide / Tables\n)\nthat look like this:\n\n\n text = \"\"\"\n... -------------------------------------------------------------\n...  Centered   Default           Right Left\n...   Header    Aligned         Aligned Aligned\n... ----------- ------- --------------- -------------------------\n...    First    row                12.0 Example of a row that\n...                                     spans multiple lines.\n... \n...   Second    row                 5.0 Here's another one. Note\n...                                     the blank line between\n...                                     rows.\n... -------------------------------------------------------------\n... \n... Table: Here's the caption. It, too, may span\n... multiple lines.\n... \"\"\"\n\n\n\nFor this multiline table, the table parser computes the relative column widths:\n\n\n table = pandoc.read(text).find(Table)\n\n _, _, widths, _, _ = table[:]\n\n widths\n[0.16666666666666666, 0.1111111111111111, 0.2222222222222222, 0.3472222222222222]\n\n\n\nNow, since the last column has a lot of content and the third one \nhas plenty of empty space, we could select relative widths to narrow \nthe third column and enlarge the last one. Here is how that looks:\n\n\n table[2] = [1/6, 1/9, 1/9, 5/12] # the sum is 1.0\n\n show(table)\n  -------------------------------------------------------------\n   Centered   Default       Right Left Aligned\n    Header    Aligned     Aligned \n  ----------- --------- --------- -----------------------------\n     First    row            12.0 Example of a row that spans\n                                  multiple lines.\n\nBLANKLINE\n\n    Second    row             5.0 Here's another one. Note the\n                                  blank line between rows.\n  -------------------------------------------------------------\n\nBLANKLINE\n\n  : Here's the caption. It, too, may span multiple lines.\n\nBLANKLINE\n\n\n\n\nOf course, it is possible to create tables programmatically:\n\n\n\n\nExample: Multiplication Table\n\n\nWe show how to build a multiplication table. \nFirst, we decide the size of the table: \nhere we will compute products up to 5x5:\n\n\n n = 5\n\n\n\nWe won't need any caption, are ok with the \ndefault column alignments and don't specify explicitly\nthe column widths:\n\n\n caption = []\n\n alignments = n * [AlignDefault()]\n\n widths = n * [0.0]\n\n\n\nNow, since the structure of a table cell in pandoc is so general, \nit may be a bit cumbersome when the content is so simple.\nTo ease this pain, we define a small \ncell\n function\nwhich creates a table cell that wraps some arbitrary \ntext-like content.\n\n\n def cell(text):\n...     inline = Str(str(text))\n...     blocks = [Plain([inline])]\n...     return blocks\n\n\n\nNow we may define the table headers\n\n\n headers = [cell(\"x\")]\n\n for j in range(1, n+1):\n...     headers.append(cell(j))\n\n\n\nand rows\n\n\n rows = []\n\n for i in range(1, n+1):\n...     row = [cell(i)]\n...     for j in range(1, n+1):\n...         row.append(cell(i * j))\n...     rows.append(row)\n\n\n\nThe final table is:\n\n\n table = Table(caption, alignments, widths, headers, rows)\n\n show(table)\n  x   1   2    3    4    5\n  --- --- ---- ---- ---- ----\n  1   1   2    3    4    5\n  2   2   4    6    8    10\n  3   3   6    9    12   15\n  4   4   8    12   16   20\n  5   5   10   15   20   25\n\nBLANKLINE", 
            "title": "Document"
        }, 
        {
            "location": "/ast/#ast-document-meta-model", 
            "text": "Use the new metaclass-based representation to drive an exploration of the\ndocument model. Link to the proper documentation when needed, or use\nexemple from markdown text to see what every construct is about.  Explore an existing document or create from scratch?\nFirst explore, then build from scratch?  Explain that the person willing to analyze/transform documents has to \nunderstand how each (or some of the) document pieces are represented?\nAnd that it's what we try to do here?    import pandoc  from pandoc.types import *  text = \"Hello, World!\"  doc = pandoc.read(text)  doc\nPandoc(Meta(map()), [Para([Str('Hello,'), Space(), Str('World!')])])  A document is an instance of the  Pandoc  class; it has two arguments   Pandoc\nPandoc(Meta, [Block])  The first argument, the instance of  Meta , represents the document metadata.\nSince in this very simple example there is no metadata, we will ignore it and\nfocus on the second argument instead, the document contents, which \nis a list of blocks:   blocks = doc[1]  blocks\n[Para([Str('Hello,'), Space(), Str('World!')])]  Actually, there is a single block here   len(blocks)\n1  There are several possible types of blocks: headers, paragraphs, lists, etc.   Block\nBlock = Plain([Inline])\n      | Para([Inline])\n      | LineBlock([[Inline]])\n      | CodeBlock(Attr, String)\n      | RawBlock(Format, String)\n      | BlockQuote([Block])\n      | OrderedList(ListAttributes, [[Block]])\n      | BulletList([[Block]])\n      | DefinitionList([([Inline], [[Block]])])\n      | Header(Int, Attr, [Inline])\n      | HorizontalRule()\n      | Table([Inline], [Alignment], [Double], [TableCell], [[TableCell]])\n      | Div(Attr, [Block])\n      | Null()  Here our single block is a paragraph:   para = blocks[0]  para\nPara([Str('Hello,'), Space(), Str('World!')])  isinstance(para, Para)\nTrue  In general, paragraphs contain lists of inline elements:   Para\nPara([Inline])  inlines = para[0]  Inlines can be several things: ordinary text, emphasized text,\nstrong text, etc.   Inline\nInline = Str(String)\n       | Emph([Inline])\n       | Strong([Inline])\n       | Strikeout([Inline])\n       | Superscript([Inline])\n       | Subscript([Inline])\n       | SmallCaps([Inline])\n       | Quoted(QuoteType, [Inline])\n       | Cite([Citation], [Inline])\n       | Code(Attr, String)\n       | Space()\n       | SoftBreak()\n       | LineBreak()\n       | Math(MathType, String)\n       | RawInline(Format, String)\n       | Link(Attr, [Inline], Target)\n       | Image(Attr, [Inline], Target)\n       | Note([Block])\n       | Span(Attr, [Inline])  Here we simply have a mixture of ordinary text and space.   inlines = para[0]  inlines\n[Str('Hello,'), Space(), Str('World!')]  Instances of  Space  have no argument while instances of  Str  \ncontain a text string   Space\nSpace()  Str\nStr(String)  String class 'str'   Finally   print(inlines[0][0] + \" \" + inlines[2][0])\nHello, World!", 
            "title": "AST / Document (Meta-)Model"
        }, 
        {
            "location": "/ast/#helpers", 
            "text": "We introduce the helper function  show  to display a document or document \nfragment (inline or block) as markdown:   def show(elt):\n...     if isinstance(elt, Pandoc):\n...         doc = elt\n...         print(pandoc.write(doc, format=\"markdown\"))\n...     elif isinstance(elt, list):\n...         elts = elt\n...         if len(elts)   0:\n...             if isinstance(elts[0], Block):\n...                 blocks = elts\n...                 show(Pandoc(Meta({}), blocks))\n...             elif isinstance(elts[0], Inline):\n...                 inlines = elts\n...                 block = Plain(elts)\n...                 show([block])\n...     elif isinstance(elt, (Inline, Block)):\n...         show([elt])  We also introduce a function  find  to get the first element of a given type\nin a document or document fragment:   def find(elt, type):\n...     for _elt in pandoc.iter(elt):\n...         if isinstance(_elt, type):\n...             return _elt  We monkey-patch the base class for pandoc types to be able to call  find  \nas a method:   pandoc.types.Type.find = find", 
            "title": "Helpers"
        }, 
        {
            "location": "/ast/#tables", 
            "text": "Reference:   Pandoc User's Guide / Tables  Simple tables in markdown typically look like this:   text = \"\"\"\n...   Right     Left     Center     Default\n... -------     ------ ----------   -------\n...      12     12        12            12\n...     123     123       123          123\n...       1     1          1             1\n... ---------------------------------------\n...\n... Table: Demonstration of simple table syntax.\n... \"\"\"  A table is defined by 5 arguments:   Table\nTable([Inline], [Alignment], [Double], [TableCell], [[TableCell]])  They define respectively the table caption, column alignments, column widths,\nheaders and rows. The most important are the last two, headers and rows.\nHeaders are described by a list of table cells: it's the content of \nfirst table row. The last argument refers to the remaining table rows,\neach row being described as a list of table cells.  The content of a table cell can be arbitrarily complex: \nanything that can be used in a document content (except for the metadata) \ncan be used in a table cell.\nActually,  TableCell  is not a new type, but an alias for \"list of blocks\":   TableCell\nTableCell = [Block]  Let's have a look at the attributes of the table above:   doc = pandoc.read(text)  table = doc.find(Table)  caption, alignments, widths, headers, rows = table[:]  Here are the column headers:   headers\n[[Plain([Str('Right')])], [Plain([Str('Left')])], [Plain([Str('Center')])], [Plain([Str('Default')])]]  for cell in headers:\n...     show(cell)\nRight BLANKLINE \nLeft BLANKLINE \nCenter BLANKLINE \nDefault BLANKLINE   The structure of rows are similar. \nFor example, we can display the contents of the first row:   rows\n[[[Plain([Str('12')])], [Plain([Str('12')])], [Plain([Str('12')])], [Plain([Str('12')])]], [[Plain([Str('123')])], [Plain([Str('123')])], [Plain([Str('123')])], [Plain([Str('123')])]], [[Plain([Str('1')])], [Plain([Str('1')])], [Plain([Str('1')])], [Plain([Str('1')])]]]  first_row = rows[0]  for cell in first_row:\n...     show(cell)\n12 BLANKLINE \n12 BLANKLINE \n12 BLANKLINE \n12 BLANKLINE   The three other table arguments are caption, column alignments and column widths.\nCaption is the obvious one: it's the content of the (optional) table caption,\ndescribed as a list of inlines:   caption\n[Str('Demonstration'), Space(), Str('of'), Space(), Str('simple'), Space(), Str('table'), Space(), Str('syntax.')]  Column alignments is a list of alignment options, \namong the four possible choices below:   Alignment\nAlignment = AlignLeft()\n          | AlignRight()\n          | AlignCenter()\n          | AlignDefault()  In the current table, the four kinds are effectively used:   alignments\n[AlignRight(), AlignLeft(), AlignCenter(), AlignDefault()]  The third argument is a list of floating-point numbers which are \nfractions of 1 and determine the column widths. \nEither their sum is one of they are all set to zero, \nin which vase the attribute carries no information. \nHere, we are in this default case:   widths\n[0.0, 0.0, 0.0, 0.0]  Column widths are relevant in the context of multiline tables\n(see  Pandoc User's Guide / Tables )\nthat look like this:   text = \"\"\"\n... -------------------------------------------------------------\n...  Centered   Default           Right Left\n...   Header    Aligned         Aligned Aligned\n... ----------- ------- --------------- -------------------------\n...    First    row                12.0 Example of a row that\n...                                     spans multiple lines.\n... \n...   Second    row                 5.0 Here's another one. Note\n...                                     the blank line between\n...                                     rows.\n... -------------------------------------------------------------\n... \n... Table: Here's the caption. It, too, may span\n... multiple lines.\n... \"\"\"  For this multiline table, the table parser computes the relative column widths:   table = pandoc.read(text).find(Table)  _, _, widths, _, _ = table[:]  widths\n[0.16666666666666666, 0.1111111111111111, 0.2222222222222222, 0.3472222222222222]  Now, since the last column has a lot of content and the third one \nhas plenty of empty space, we could select relative widths to narrow \nthe third column and enlarge the last one. Here is how that looks:   table[2] = [1/6, 1/9, 1/9, 5/12] # the sum is 1.0  show(table)\n  -------------------------------------------------------------\n   Centered   Default       Right Left Aligned\n    Header    Aligned     Aligned \n  ----------- --------- --------- -----------------------------\n     First    row            12.0 Example of a row that spans\n                                  multiple lines. BLANKLINE \n    Second    row             5.0 Here's another one. Note the\n                                  blank line between rows.\n  ------------------------------------------------------------- BLANKLINE \n  : Here's the caption. It, too, may span multiple lines. BLANKLINE   Of course, it is possible to create tables programmatically:   Example: Multiplication Table  We show how to build a multiplication table. \nFirst, we decide the size of the table: \nhere we will compute products up to 5x5:   n = 5  We won't need any caption, are ok with the \ndefault column alignments and don't specify explicitly\nthe column widths:   caption = []  alignments = n * [AlignDefault()]  widths = n * [0.0]  Now, since the structure of a table cell in pandoc is so general, \nit may be a bit cumbersome when the content is so simple.\nTo ease this pain, we define a small  cell  function\nwhich creates a table cell that wraps some arbitrary \ntext-like content.   def cell(text):\n...     inline = Str(str(text))\n...     blocks = [Plain([inline])]\n...     return blocks  Now we may define the table headers   headers = [cell(\"x\")]  for j in range(1, n+1):\n...     headers.append(cell(j))  and rows   rows = []  for i in range(1, n+1):\n...     row = [cell(i)]\n...     for j in range(1, n+1):\n...         row.append(cell(i * j))\n...     rows.append(row)  The final table is:   table = Table(caption, alignments, widths, headers, rows)  show(table)\n  x   1   2    3    4    5\n  --- --- ---- ---- ---- ----\n  1   1   2    3    4    5\n  2   2   4    6    8    10\n  3   3   6    9    12   15\n  4   4   8    12   16   20\n  5   5   10   15   20   25 BLANKLINE", 
            "title": "Tables"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\nIntroduction\n\n\nThe good news are that you generally don't need to configure anything:\nwhen you use the \npandoc\n Python library,\nit does inspect your system to find the available \npandoc\n \ncommand-line tool and configures itself accordingly. \nMost of the time, this is what you want.\n\n\nHowever, if you need more control on this configuration step,\nyou can import \npandoc\n and call \nconfigure\n\nbefore you do anything else with the library:\n\n\nimport pandoc\npandoc.configure(...)\n\n\n\nIf you do this, the implicit configuration does not take place;\nit is triggered only when no configuration is specified when \n\n\n\n\n\n\nyou import \npandoc.types\n or\n\n\n\n\n\n\nyou call \npandoc.read\n or \npandoc.write\n. \n\n\n\n\n\n\nOptions\n\n\nTo have the library find a \npandoc\n executable in your path, \nand configure itself accordingly, enable the \nauto\n option\n\n\npandoc.configure(auto=True)\n\n\n\nThis is the method used by the implicit configuration.\nIf instead you want to specify manually the pandoc executable,\nuse the \npath\n argument, for example:\n\n\npandoc.configure(path='/usr/bin/pandoc')\n\n\n\nSome features\n1\n of the Python \npandoc\n library \ndo not require the \npandoc\n executable, but in this case \nwe still need to know what version of pandoc you target,\nso specify for example:\n\n\npandoc.configure(version='1.16.0.2')\n\n\n\nActually, the exact version of pandoc is not even required. \nInstead what matters is the version of the document model \nthat you intend to use, or equivalently, the version of the\n\npandoc-types\n Haskell package used by the pandoc executable.\nAccordingly, you may configure \npandoc\n with the \n\npandoc_types_version\n argument:\n\n\npandoc.configure(pandoc_types_version='1.16.1.1')\n\n\n\nExtra Arguments\n\n\nTo get a copy of the configuration\n(or \nNone\n if the library is not configured yet),\nenable the \nread\n option. The call \n\n\npandoc.configure(read=True)\n\n\n\ndoes not change the current configuration \nbut returns a dictionary whose keys are \nauto\n, \npath\n, \n\nversion\n and \npandoc_types_version\n, such as\n\n\n{\n  'auto': True, \n  'path': '/usr/bin/pandoc', \n  'version': '1.16.0.2', \n  'pandoc_types_version': '1.16.1.1'\n}\n\n\n\nThe \nread\n option may be combined with other arguments, for example\n\n\nconfig = pandoc.configure(auto=True, read=True)\n\n\n\nThis is actually a good way to know where the pandoc executable has been\nfound, what is its version and the corresponding version of \npandoc-types\n.\n\n\nWhen it is needed, it is also possible to restore the unconfigured state:\n\n\npandoc.configure(reset=True)\n\n\n\n\n\n\n\n\n\n\n\ntypically conversion between json and Python object representations \nof documents and analysis or transformations of documents as Python objects.\nAs soon as you use convert to or from any other format, markdown for example,\nyou need a pandoc executable.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#introduction", 
            "text": "The good news are that you generally don't need to configure anything:\nwhen you use the  pandoc  Python library,\nit does inspect your system to find the available  pandoc  \ncommand-line tool and configures itself accordingly. \nMost of the time, this is what you want.  However, if you need more control on this configuration step,\nyou can import  pandoc  and call  configure \nbefore you do anything else with the library:  import pandoc\npandoc.configure(...)  If you do this, the implicit configuration does not take place;\nit is triggered only when no configuration is specified when     you import  pandoc.types  or    you call  pandoc.read  or  pandoc.write .", 
            "title": "Introduction"
        }, 
        {
            "location": "/configuration/#options", 
            "text": "To have the library find a  pandoc  executable in your path, \nand configure itself accordingly, enable the  auto  option  pandoc.configure(auto=True)  This is the method used by the implicit configuration.\nIf instead you want to specify manually the pandoc executable,\nuse the  path  argument, for example:  pandoc.configure(path='/usr/bin/pandoc')  Some features 1  of the Python  pandoc  library \ndo not require the  pandoc  executable, but in this case \nwe still need to know what version of pandoc you target,\nso specify for example:  pandoc.configure(version='1.16.0.2')  Actually, the exact version of pandoc is not even required. \nInstead what matters is the version of the document model \nthat you intend to use, or equivalently, the version of the pandoc-types  Haskell package used by the pandoc executable.\nAccordingly, you may configure  pandoc  with the  pandoc_types_version  argument:  pandoc.configure(pandoc_types_version='1.16.1.1')", 
            "title": "Options"
        }, 
        {
            "location": "/configuration/#extra-arguments", 
            "text": "To get a copy of the configuration\n(or  None  if the library is not configured yet),\nenable the  read  option. The call   pandoc.configure(read=True)  does not change the current configuration \nbut returns a dictionary whose keys are  auto ,  path ,  version  and  pandoc_types_version , such as  {\n  'auto': True, \n  'path': '/usr/bin/pandoc', \n  'version': '1.16.0.2', \n  'pandoc_types_version': '1.16.1.1'\n}  The  read  option may be combined with other arguments, for example  config = pandoc.configure(auto=True, read=True)  This is actually a good way to know where the pandoc executable has been\nfound, what is its version and the corresponding version of  pandoc-types .  When it is needed, it is also possible to restore the unconfigured state:  pandoc.configure(reset=True)      typically conversion between json and Python object representations \nof documents and analysis or transformations of documents as Python objects.\nAs soon as you use convert to or from any other format, markdown for example,\nyou need a pandoc executable.", 
            "title": "Extra Arguments"
        }, 
        {
            "location": "/api/", 
            "text": "API Reference", 
            "title": "API Reference"
        }, 
        {
            "location": "/api/#api-reference", 
            "text": "", 
            "title": "API Reference"
        }
    ]
}